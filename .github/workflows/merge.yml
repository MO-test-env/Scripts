name: Merge

on:
  workflow_call:
    inputs:
      username:
        description: 'User that triggered the workflow'
        required: true
        type: string
      owner:
        description: 'Organization'
        required: true
        type: string
      repo:
        description: 'Repository'
        required: true
        type: string
      pr_number:
        description: 'PR Number'
        required: true
        type: number
      comment_id:
        description: 'Comment ID'
        required: true
        type: number
    secrets:
      token:
        description: 'Personal Access Token with RW access to repo contents, PRs'
        required: true
      # gpg_private_key:
      #   description: 'GPG Private Key'
      #   required: true
      # gpg_key_id:
      #   description: 'GPG Key ID'
      #   required: true

permissions:
  issues: write
  pull-requests: write
  contents: write

env:
  RW_PAT: ${{ secrets.token }}
  MIN_REVIEWERS: 0
  USERNAME: ${{ inputs.username }}
  OWNER: ${{ inputs.owner }}
  REPO: ${{ inputs.repo }}
  BASE_PR_NUMBER: ${{ inputs.pr_number }}
  COMMENT_ID: ${{ inputs.comment_id }}

concurrency:
  group: merge-operations-${{ inputs.owner }}-${{ inputs.repo }}
  cancel-in-progress: false

jobs:
  merge-chain:
    runs-on: ubuntu-latest
    timeout-minutes: 3
    steps:
      - name: Get pr-utils.js using GitHub API
        id: get-pr-utils
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Create utils directory and scripts subdirectory
            fs.mkdirSync('utils/scripts', { recursive: true });
            
            // Get pr-utils.js content from repository
            try {
              const { data } = await github.rest.repos.getContent({
                owner: 'MO-test-env',
                repo: 'orgScripts',
                path: 'scripts/pr-utils.js',
                ref: 'main'
              });
              
              // Decode content and write to file
              const content = Buffer.from(data.content, 'base64').toString();
              fs.writeFileSync('utils/scripts/pr-utils.js', content);
              console.log('Successfully retrieved pr-utils.js');
            } catch (error) {
              core.setFailed(`Failed to get pr-utils.js: ${error.message}`);
              return;
            }

      - name: Comment start 
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const fs = require('fs');
            const path = require('path');
            const prUtils = require('./utils/scripts/pr-utils.js'); 
            const runUrl = `https://github.com/${owner}/${repo}/actions/runs/${process.env.GITHUB_RUN_ID}`;
            let appendMsg = "\n # üîß Merge workflow started #\n";
            appendMsg = appendMsg + `[üñ•Ô∏è View this workflow run](${runUrl})`;
            appendMsg = appendMsg + "\n**_(Step 1/5)_** Initializing \n - Checking user permissions.";
            await prUtils.appendComment(github, commentId, owner, repo, appendMsg);
        
      - name: Check User Permissions 
        id: permissions
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            let username = process.env.USERNAME;
            core.info(`User: ${username}`);
            if ( !username ) {
              core.setFailed(`Username not found`);
              core.setOutput('failMsg', 'Workflow stopped because username could not be found from github.actor');
              return;
            }
            try {
              core.info(`Confirming user has access to ${process.env.OWNER}/${process.env.REPO}`);
              // Check if user has access to the repo
              await github.rest.repos.checkCollaborator({
                owner:process.env.OWNER,
                repo: process.env.REPO,
                username
              });
              
              // Check if user is an org member
              try {
                core.info(`Checking if ${process.env.USERNAME} is a member of ${process.env.OWNER}`);
                const membership = await github.rest.orgs.getMembershipForUser({
                  org: process.env.OWNER, 
                  username,
                });
                core.info(`Membership state: ${membership.data.state}`);
                core.info(`Role: ${membership.data.role}`);
                
                if (membership.data.state !== 'active') {
                  core.setFailed(`User is not an active org member`);
                  core.setOutput("failMsg", `Workflow stopped because user is not an active member of the ${process.env.OWNER} organization.`);
                  return;
                }
                // They're an org member with repo access
                core.info(`User: ${username} is a member of ${process.env.OWNER} and allowed to merge.`);
                core.setOutput('UserType', 'internal');
                return; 

              } catch (error) {
                if (error.status === 404) {
                  // User has repo access but is not an org member so must be an external collaborator
                  core.info(`User: ${username} is a collaborator of ${process.env.OWNER} - this doesnt matter for MO repo `);
                }
              }
            } catch (error) {
              if (error.status === 404) {
                // No access to repo (this should never happen)
                core.setFailed(`User does not have access to the repo`);
                core.setOutput('failMsg', 'Workflow stopped because user does not have access to the repo.');
                return;
              }
            }

      - name: Get BasePR details
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = process.env.BASE_PR_NUMBER;
            const pr = await github.rest.pulls.get({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: prNumber,
            });
            core.setOutput("head_ref", pr.data.head.ref);
            core.setOutput("base_ref", pr.data.base.ref);
            core.setOutput("pr_number", pr.data.number);
            core.setOutput("title", pr.data.title);
            core.setOutput("body", pr.data.body);
            core.setOutput("mergeable", pr.data.mergeable);
            core.setOutput("merged", pr.data.merged);
            core.setOutput("mergeable_state", pr.data.mergeable_state);
            core.setOutput("state", pr.data.state);

            // Get default branch of base repo 
            const { data: repo } = await github.rest.repos.get({
              owner: process.env.OWNER,
              repo: process.env.REPO,
            });
            core.setOutput("default_branch", repo.default_branch);
            core.setOutput("isMergeIntoDefaultBranch", pr.data.base.ref == repo.default_branch);

            // Confirm early stops 
            // STOP if base is already merged or closed
            if (pr.data.merged == true || pr.data.state == 'closed' ){ 
              core.setFailed("Workflow stopped because the base PR is already merged.");
              core.setOutput("failMsg", "Workflow stopped because the base PR is already merged.");
              return;
            }
            // STOP if the PR has no changes, avoid empty commits
            if( (pr.data.additions == 0 && pr.data.deletions == 0) || (pr.data.changed_files == 0) ){
              core.setFailed("Workflow stopped because the base PR has no changes.");
              core.setOutput("failMsg", "Workflow stopped because the base PR has no changes.");
              return;
            }

      - name: Comment on PR info success 
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const fs = require('fs');
            const path = require('path');
            const prUtils = require('./utils/scripts/pr-utils.js'); 
            let appendMsg = "\n - Successfully checked user permissions and base PR data.\n - Reading .gitmodules file and determining branch strategy based on PR base_ref.";
            if('${{ steps.pr.outputs.merged}}' == 'true'){
              appendMsg = "\n ## Nothing to merge. ##"
            }
            await prUtils.appendComment(github, commentId, owner, repo, appendMsg);

      # PRE-CHECK BASE for conflicts and approvals 
      - name: Confirm Approvals for base PR
        id: base-approvals
        if: ${{ steps.pr.outputs.merged == 'false' }}
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = process.env.BASE_PR_NUMBER;
            const fs = require('fs');
            const path = require('path');
            const prUtils = require('./utils/scripts/pr-utils.js'); 
            let approvalCount = 0;
            
            try {
              const result = await prUtils.checkPrApprovals(
                github, 
                core, 
                prNumber, 
                process.env.OWNER, 
                process.env.REPO
              );
              approvalCount = result.approvalCount;
            } catch (error) {
              core.setFailed(`Failed to check PR approvals: ${error.message}`);
              core.setOutput("failMsg", `Workflow stopped because failed to check PR approvals: ${error.message}`);
              return;
            }

            console.log(` Current approvals: ${approvalCount}/${process.env.MIN_REVIEWERS}`);

            if (approvalCount < parseInt(process.env.MIN_REVIEWERS || '0', 10)) {
              core.setFailed(` Not enough approvals (${approvalCount}/${process.env.MIN_REVIEWERS})`);
              core.setOutput("failMsg", `(${approvalCount}/${process.env.MIN_REVIEWERS})`);
              return;
            } else {
              console.log(' Required approvals met.');
            }
      # Determine PR conflicts and changed submod from PR diff 
      - name: Determine changed submodules from PR diff
        id: diff-submodules
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = process.env.BASE_PR_NUMBER;
            const fs = require('fs');
            const path = require('path');
            const prUtils = require('./utils/scripts/pr-utils.js'); 
            let result = {};
            
            try {
              result = await prUtils.submodDiff(
                github, 
                core, 
                prNumber, 
                process.env.OWNER, 
                process.env.REPO
              );
            } catch (error) {
              core.setFailed(`Failed to determine changed submodules: ${error.message}`);
              core.setOutput("failMsg", `Workflow stopped because failed to determine changed submodules: ${error.message}`);
              return;
            }
            
            core.setOutput("changed_paths", JSON.stringify(result.changed_submodules));
            core.setOutput("conflicted_non_submodule_files", JSON.stringify(result.files_with_conflicts));
            core.setOutput("enriched_submodules", JSON.stringify(result.enriched_submodules));

      # pre-check submodules for conflicts and approvals 
      - name: Pre-check all Submodules and add additional submodule fields 
        id: pre-check-submod
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.diff-submodules.outputs.enriched_submodules }}
          PR_BRANCH: ${{ steps.pr.outputs.head_ref }}
          BASE_BRANCH: ${{ steps.pr.outputs.base_ref }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const submods = JSON.parse(process.env.SUBMODULES_JSON);
            const submodulesAfterPrecheck = {};
            const prBranchName = process.env.PR_BRANCH;
            const baseBranchName = process.env.BASE_BRANCH;
            const fs = require('fs');
            const path = require('path');
            const prUtils = require('./utils/scripts/pr-utils.js'); 
            
            for (const [name, sub] of Object.entries(submods)) { 
              let prNumber = sub.prNumber;
              // If we already have a PR number from the previous step, use it
              if (prNumber !== null && prNumber !== undefined) {
                if (prNumber === 0) {
                  // Already merged (no pre-check needed)
                  submodulesAfterPrecheck[name] = {
                    ...sub,
                    prLink: null,
                    isPRCreated: false,
                    merged: true,
                    mergeableState: 'clean', 
                    approvals: null,
                  };
                } else if (prNumber === -1) {
                  // PR not created yet (no precheck needed)
                  submodulesAfterPrecheck[name] = {
                    ...sub,
                    prLink: null,
                    isPRCreated: false,
                    merged: false, 
                    approvals: null,
                  };
                } else {
                  // PR exists, need to pre-check/ fetch more info 
                    try {
                      // Check mergeability/ conflicts
                      // Retry logic for getting PR info when merged or mergeable_state is undefined
                      let prInfo = null;
                      let retryCount = 0;
                      const maxRetries = 3;
                      const retryDelay = 1000; // 1 second delay between retries
                      
                      while (retryCount <= maxRetries) {
                        try {
                          const response = await github.rest.pulls.get({
                            owner: process.env.OWNER,
                            repo: sub.repoName,
                            pull_number: prNumber
                          });
                          prInfo = response.data;
                          
                          // Check if we got the required information
                          if (prInfo.merged !== undefined && prInfo.mergeable_state !== undefined) {
                            break; // Success, exit retry loop
                          }
                          
                          // If we don't have the required info, retry if we haven't exceeded max retries
                          if (retryCount < maxRetries) {
                            retryCount++;
                            core.info(`PR info incomplete (merged: ${prInfo.merged}, mergeable_state: ${prInfo.mergeable_state}), retrying... (${retryCount}/${maxRetries})`);
                            await new Promise(resolve => setTimeout(resolve, retryDelay));
                          } else {
                            break; // Max retries reached
                          }
                        } catch (error) {
                          // If we get an error and haven't exceeded max retries, retry
                          if (retryCount < maxRetries) {
                            retryCount++;
                            core.info(`Error getting PR info: ${error.message}, retrying... (${retryCount}/${maxRetries})`);
                            await new Promise(resolve => setTimeout(resolve, retryDelay));
                          } else {
                            throw error; // Re-throw if max retries reached
                          }
                        }
                      }
                      
                      // If we still don't have the required info after retries, log a warning
                      if (prInfo.merged === undefined || prInfo.mergeable_state === undefined) {
                        core.warning(`PR info still incomplete after retries (merged: ${prInfo.merged}, mergeable_state: ${prInfo.mergeable_state})`);
                      }

                      // Check approvals 
                      let approvalCount = 0;
                      let changeRequestCount = 0;
                      
                      try {
                        const result = await prUtils.checkPrApprovals(
                          github, 
                          core, 
                          prNumber, 
                          process.env.OWNER, 
                          sub.repoName
                        );
                        approvalCount = result.approvalCount;
                        changeRequestCount = result.changeRequestCount;
                      } catch (error) {
                        console.log(`Error checking approvals for submodule ${name}: ${error.message}`);
                        // Continue with default values rather than failing the entire workflow
                      }
                      const prState = prInfo.number === 0 ? null : prInfo.merged_at ? 'merged' : prInfo.state === 'closed' ? 'closed' : 'open';
                      
                      // Push full object 
                      submodulesAfterPrecheck[name] = {
                        ...sub,
                        prLink: prInfo.html_url,
                        isPRCreated: true,
                        prState: prState,
                        merged: prInfo.merged,
                        mergeableState: prInfo.mergeable_state,
                        approvals: approvalCount,
                        changeRequests: changeRequestCount,
                      };
                    } catch (error) {
                      console.log(`Error getting additional PR info for submodule ${name}: ${error.message}`);
                    }
                }
                continue;
              }
            }
            
            // Convert object to array for output and later steps 
            const submodulesArray = Object.values(submodulesAfterPrecheck);
            const submodulesAfterPrecheckJson = JSON.stringify(submodulesArray, null, 2);
            core.info("Submodule JSON:");
            core.info(submodulesAfterPrecheckJson);
              core.setOutput('submod_after_precheck', submodulesAfterPrecheckJson);
            
            // Filter only unmerged submodules
            const unmerged = submodulesArray.filter(s => s.merged === false);
            const unmergedJson = JSON.stringify(unmerged, null, 2);
            core.info("Unmerged submodules:");
            core.info(unmergedJson);
            core.setOutput('unmerged', unmergedJson);
            

            // Simple validation: ensure the number of submodules from the diff step matches the number in the pre-check step
            const submodulesFromDiff = JSON.parse(process.env.SUBMODULES_JSON);
            const diffSubmoduleCount = Object.keys(submodulesFromDiff).length;
            const precheckSubmoduleCount = submodulesArray.length;
            
            core.info(`Submodules from diff step: ${diffSubmoduleCount}, Submodules from pre-check step: ${precheckSubmoduleCount}`);
            
            // If the counts don't match, fail
            if (diffSubmoduleCount !== precheckSubmoduleCount) {
              const errorMsg = `Mismatch between submodules from diff step (${diffSubmoduleCount}) and pre-check step (${precheckSubmoduleCount}).`;
              core.warning(errorMsg);
              core.setOutput('failMsg', errorMsg);
            } else {
              core.info("Submodule counts match, validation passed.");
            }

      # shallow checkout base 
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          token:       ${{ env.RW_PAT }}
          ref:         ${{ steps.pr.outputs.base_ref }}
          fetch-depth: 1
          submodules:  true
          sparse-checkout: |
            .gitmodules
          sparse-checkout-cone-mode: false
          filter: blob:none  
      # the checkout above clears out the file that had previously been loaded.  
      # I need to wait until after the base pr info has been parsed so I dont want to checkout too early.
      # I also do not want to commit and save the file to the repo  
      - name: Get pr-utils.js using GitHub API
        id: get-pr-utils-2
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Create utils directory and scripts subdirectory
            fs.mkdirSync('utils/scripts', { recursive: true });
            
            // Get pr-utils.js content from repository
            try {
              const { data } = await github.rest.repos.getContent({
                owner: 'MO-test-env',
                repo: 'orgScripts',
                path: 'scripts/pr-utils.js',
                ref: 'main'
              });
              
              // Decode content and write to file
              const content = Buffer.from(data.content, 'base64').toString();
              fs.writeFileSync('utils/scripts/pr-utils.js', content);
              console.log('Successfully retrieved pr-utils.js');
            } catch (error) {
              core.setFailed(`Failed to get pr-utils.js: ${error.message}`);
              return;
            }
      

      # setup GPG and auth for bot user 
      # setup GPG and auth for bot user 
      - name: Config Bot User, GPG, and init changed submodules 
        id: auth
        run: |
          # echo "${{ secrets.gpg_private_key }}" | gpg --batch --import
          git config --global commit.gpgsign true
          git config --global user.name "MO"
          git config --global user.email "movenshire@tamu.edu"
          # git config --global user.signingkey "${{ secrets.gpg_key_id }}"
          git config --global url."https://${{ env.RW_PAT }}:x-oauth-basic@github.com/".insteadOf "https://github.com/"

          # First, fetch only what we need from the repository
          echo "Fetching minimal repository data..."
          git fetch --no-tags --deepen=99999 origin ${{steps.pr.outputs.base_ref}}
          git fetch --no-tags --deepen=99999 origin ${{steps.pr.outputs.head_ref}}

      # THE FOLLOWING IS NOW HANDLED IN MERGE PROCESS DIRECTLY
      # - If there are submodule ptr conflicts resolve them here. If an issue arises we do not want this PR left in a partially merged state. 
      # - squash all commits and push back up to pr branch 
      # - manual rebase to resolve pointer conflicts 
      # - sign and push up to pr brnach 
      
      # merge submods 
        ## squash all commits if needed sign and push back up to pr branch 
        ## pre-form commit title and body (including pr link)
        ## sign and commit submodule merge  

      - name: Merge Submodules
        id: merge-submodules
        uses: actions/github-script@v7
        env:
          SUBMODULES: ${{ steps.pre-check-submod.outputs.unmerged }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const prUtils = require('./utils/scripts/pr-utils.js');

            const submodules = JSON.parse(process.env.SUBMODULES);
            const mergeResults = [];
            
            for (const sub of submodules){
              console.info(`üîé Processing submodule: ${JSON.stringify(sub)}`);
              let retryCount = 0;
              const owner = process.env.OWNER;
              const repo = sub.repoName || await prUtils.deriveRepoNameFromUrl(sub.url);
              const pr = sub.prNumber;
              const { data: prInfo } = await github.rest.pulls.get({ owner, repo, pull_number: pr });
              
              // Check if merge would be an empty commit
              const { data: comparison } = await github.rest.repos.compareCommits({
                owner,
                repo,
                base: prInfo.base.sha,
                head: prInfo.head.sha
              });
              
              if (comparison.files.length === 0 && comparison.commits.length === 0) {
                console.log(`‚ö†Ô∏è Skipping merge of ${sub.name} PR #${pr} as it would result in an empty commit. Closing submodule PR. User can reopen if needed`);
                mergeResults.push({
                  name: sub.name,
                  pr: pr,
                  merged: false,
                  skipped: true,
                  reason: 'empty_commit'
                });
                await github.rest.pulls.update({
                  owner,
                  repo,
                  pull_number: pr,
                  state: 'closed'
                });
                continue;
              }
              
              // Proceed with merge
              while (retryCount < 3){
                // This should never need to happen more than once, but sometimes api calls fail so looping adds some additional certainty. 
                try {
                  // Get PR details to get head and base branches
                  const { data: prDetails } = await github.rest.pulls.get({
                    owner,
                    repo,
                    pull_number: pr
                  });
                  
                  const headRef = prDetails.head.ref;
                  const baseRef = prDetails.base.ref;
                  const remote = 'origin';
                  
                  // Call localGitMergePipeline
                  let result = '';
                  
                  try {
                    result = await prUtils.localGitMergePipeline(
                      core,
                      remote,
                      pr,
                      baseRef,
                      headRef,
                      false,
                      [],
                      owner, 
                      repo,
                      sub.path
                    );
                  } catch (error) {
                    core.setFailed(`Failed to merge submodule ${sub.name} PR #${pr}: ${error.message}`);
                    core.setOutput("failMsg", `Workflow stopped because failed to merge submodule ${sub.name} PR #${pr}: ${error.message}`);
                    return;
                  }
                  
                  // Get the SHA of the merged commit
                  const { data: branchData } = await github.rest.repos.getBranch({
                    owner,
                    repo,
                    branch: baseRef
                  });
                  
                  const mergedSha = branchData.commit.sha;
                  
                  // Save the merged SHA
                  mergeResults.push({
                    name: sub.name,
                    pr: pr,
                    merged: true,
                    merged_sha: mergedSha,
                    message: result
                  });
                  break;
                } catch (error) {
                  retryCount++;
                  console.error(`Failed to merge submodule ${sub.name} PR #${pr}: ${error.message}`);
                  if (retryCount === 3) {
                    mergeResults.push({
                      name: sub.name,
                      pr: pr,
                      merged: false,
                      error: error.message
                    });
                    throw error;
                  }
                }
              }
            }
            
            // Output merge results
            const mergeResultsJson = JSON.stringify(mergeResults, null, 2);
            core.info("Merge results:");
            core.info(mergeResultsJson);
            core.setOutput('merge_results', mergeResultsJson);

      # BUMP SUBSMODULES
      - name: Bump submodules
        id: bump
        uses: actions/github-script@v7
        env:
          SUBMODULES: ${{ steps.pre-check-submod.outputs.submodules  }}
          TOKEN: ${{ env.RW_PAT }}
          BRANCH: ${{steps.pr.outputs.head_ref}}
          BASE_REF: ${{ steps.pr.outputs.base_ref }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            // API calls were the most lightweight and fastest way to do this logic. If you are curious about trees vs branches vs commits vs subtrees vs raw refs, there are some great online resources or I am happy to chat and talk through it. 
            const { execSync } = require('child_process');
            const submodules = JSON.parse(process.env.SUBMODULES);
            const headRef = process.env.BRANCH;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            
            // Get the current commit SHA for the branch
            const { data: refData } = await github.rest.git.getRef({
              owner,
              repo,
              ref: `heads/${headRef}`
            });
            const currentBranchSha = refData.object.sha;
            
            // Get the current tree
            const { data: commitData } = await github.rest.git.getCommit({
              owner,
              repo,
              commit_sha: currentBranchSha
            });
            const currentTreeSha = commitData.tree.sha;
            
            // Prepare tree updates for submodules
            const treeUpdates = [];
            let needsUpdate = false;
            
            // Process each submodule
            for (const sub of submodules) {
              const path = sub.path;
              const subOwner = owner;
              const subRepo = sub.name;
              const branch = sub.base_branch;
              
              console.log(`üîß Processing submodule ${subRepo} at path ${path} on branch ${branch}`);
              
              try {
                // Get the latest commit on the branch 
                const { data: branchData } = await github.rest.repos.getBranch({
                  owner: subOwner,
                  repo: subRepo,
                  branch: branch
                });
                
                const latestCommit = branchData.commit.sha;
                console.log(`Latest commit on ${branch} for ${subRepo}: ${latestCommit}`);
                
                // Get current submodule commit if possible
                let currentCommit = '';
                try {
                  // Try to get the current submodule commit from the tree
                  const { data: treeData } = await github.rest.git.getTree({
                    owner,
                    repo,
                    tree_sha: currentTreeSha,
                    recursive: 1
                  });
                  
                  const submoduleItem = treeData.tree.find(item => 
                    item.path === path && item.type === 'commit'
                  );
                  
                  if (submoduleItem) {
                    currentCommit = submoduleItem.sha;
                    console.log(`Current commit for ${path}: ${currentCommit}`);
                  }
                } catch (e) {
                  console.log(`Could not determine current commit for ${path}: ${e.message}`);
                }
                
                // If submodule needs updating
                if (currentCommit !== latestCommit) {
                  console.log(`‚ö†Ô∏è Submodule ${subRepo} needs update from ${currentCommit || 'unknown'} to ${latestCommit}`);
                  
                  // Add to tree updates
                  treeUpdates.push({
                    path: path,
                    mode: '160000', // Submodule mode - have probably seen this when committing or doing diff locally 
                    type: 'commit',
                    sha: latestCommit
                  });
                  
                  needsUpdate = true;
                  //NOTE nothing up here is actually pushing to your PR branch. 
                } else {
                  console.log(`‚úÖ Submodule ${subRepo} is already up-to-date at ${currentCommit}`);
                }
              } catch (error) {
                console.log(`‚ö†Ô∏è Error processing submodule ${subRepo}: ${error.message}`);
              }
            }
            
            // If any submodules need updating, create a new commit
            // This should basically always happen but protects from extraneous commits  
            if (needsUpdate) {
              try {
                // Create a new tree based on the treeUpdates we initialized and pushed to above
                const { data: newTree } = await github.rest.git.createTree({
                  owner,
                  repo,
                  base_tree: currentTreeSha,
                  tree: treeUpdates
                });
                
                // Create a commit
                const { data: newCommit } = await github.rest.git.createCommit({
                  owner,
                  repo,
                  message: `Bump submodules to default branch from base PR ${process.env.BASE_REF}`,
                  tree: newTree.sha,
                  parents: [currentBranchSha]
                });
                
                // Update the PR branch reference with the new tree 
                await github.rest.git.updateRef({
                  owner,
                  repo,
                  ref: `heads/${headRef}`,
                  sha: newCommit.sha,
                  force: false
                });
                
                console.log(`‚úÖ Successfully updated submodules with commit ${newCommit.sha}`);
                core.setOutput('updated', 'true');
                core.setOutput('commit_sha', newCommit.sha);
              } catch (error) {
                console.log(`‚ùå Error updating submodules: ${error.message}`);
                core.setFailed(`Failed to update submodules: ${error.message}`);
              }
            } else {
              console.log('‚úÖ All submodules already up-to-date.');
              core.setOutput('updated', 'false');
            }

      # merge base 
        ## pre-form commit title and body including pr link
        ## sign and commit base merge

      # MERGE BASE
      - name: Merge base PR
        id: merge-base
        uses: actions/github-script@v7
        env:
          BRANCH: ${{steps.pr.outputs.head_ref}}
          BASE_BRANCH: ${{steps.pr.outputs.base_ref}}
          OWNER: ${{ inputs.owner }}
          REPO: ${{ inputs.repo }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            // Import the pr-utils.js module
            const fs = require('fs');
            const path = require('path');
            const prUtils = require('./utils/scripts/pr-utils.js');
            const prNumber = parseInt(process.env.BASE_PR_NUMBER);
            const headRef = process.env.BRANCH;
            const baseRef = process.env.BASE_BRANCH;
            const remote = 'origin';
            
            // Get changed submodules if any
            let submodules = [];
            try {
              const changedPathsStr = '${{ steps.diff-submodules.outputs.changed_paths }}';
              if (changedPathsStr && changedPathsStr !== '[]') {
                submodules = JSON.parse(changedPathsStr);
              }
            } catch (error) {
              core.warning(`Failed to parse changed submodules: ${error.message}`);
            }
            
            try {
              // Use localGitMergePipeline instead of github.rest.pulls.merge
              const result = await prUtils.localGitMergePipeline(
                core,
                remote,
                prNumber,
                baseRef,
                headRef,
                true,
                submodules,
                process.env.OWNER,
                process.env.REPO,
                ''
              );
              
              core.info(`Merge result: ${result}`);
              core.setOutput('result', 'success');
              core.setOutput('message', result);
            } catch (error) {
              core.setFailed(`Failed to merge PR: ${error.message}`);
              core.setOutput('result', 'failure');
              core.setOutput('message', error.message);
            }



      ## COMMENTING STEPS 
      - name: Comment on submodule precheck
        uses: actions/github-script@v7
        env:
          UPDATED_GIT_MODULES: ${{ steps.diff-submodules.outputs.updated_git_modules }}
          BASE_STATE: ${{ steps.pr.outputs.state }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const fs = require('fs');
            const path = require('path');
            const prUtils = require('./utils/scripts/pr-utils.js');
            let appendMsg = "\n - Base PR has enough approvals.";

            const updatedGitModules = process.env.UPDATED_GIT_MODULES || '{}';
            const baseState = process.env.BASE_STATE || '';
            if ( updatedGitModules != '{}') {
              if ( baseState == 'open' )
              {
                appendMsg +="\n - Commits squashed\n - Rebase pushed successfully to resolve submodule conflicts. ";
              }
              appendMsg = appendMsg + "\n - Running submodule pre-check.";
            }else {
              appendMsg = appendMsg + "\n - No submodules detected skipping to merge base.";
            }
            await prUtils.appendComment(github, commentId, owner, repo, appendMsg);

      - name: Comment on Pre-check Success
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const fs = require('fs');
            const path = require('path');
            const prUtils = require('./utils/scripts/pr-utils.js'); 
            const unmergedSubmodules = process.env.UNMERGED_SUBMODULES;
            const ifEmptyUnmergedArr = unmergedSubmodules == "[]";
            let newBody = "";
            if(!ifEmptyUnmergedArr){
              newBody += "\n\n" + "**_(Step 2/5)_** Starting to merge submodules.";
            }
            else{
              newBody += "\n\n" + "**_(Step 2/5)_** Skipping submodule merge. All submodules are already merged";
            }
            await prUtils.appendComment(github, commentId, owner, repo, newBody);

      - name: Comment after Merging submods 
        uses: actions/github-script@v7
        env:
          MERGE_RESULTS: ${{ steps.merge-submodules.outputs.merge_results }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const fs = require('fs');
            const path = require('path');
            const prUtils = require('./utils/scripts/pr-utils.js'); 
            
            let newBody = "\n";
            const result = "${{ steps.merge-submodules.conclusion }}";
            
            // Add details about merge results if available
            if (process.env.MERGE_RESULTS) {
              try {
                const mergeResults = JSON.parse(process.env.MERGE_RESULTS);
                if (mergeResults.length > 0) {
                  newBody += "\n**Submodule merge details:**\n";
                  
                  for (const result of mergeResults) {
                    if (result.skipped) {
                      newBody += `- ‚ö†Ô∏è Skipped ${result.name} PR #${result.pr}: ${result.reason === 'empty_commit' ? 'Would result in empty commit' : result.reason}\n`;
                    } else if (result.merged) {
                      newBody += `- Merged ${result.name} PR # ${result.pr} (SHA: ${result.merged_sha.substring(0, 7)})\n`;
                    } else {
                      newBody += `- Failed to merge ${result.name} PR #${result.pr}: ${result.error || 'Unknown error'}\n`;
                    }
                  }
                }
              } catch (error) {
                console.error(`Error parsing merge results: ${error.message}`);
              }
            }
            if( result == "skipped")
            {
              newBody += "\n\n**_(Step 3/5)_** Beginning to bump submodules for base PR branch.";
            }
            else
            {
              newBody += " - All submodules merged.\n\n**_(Step 3/5)_** Beginning to bump submodules for base PR branch.";
            }
            await prUtils.appendComment(github, commentId, owner, repo, newBody);
      
      - name: Comment after Bump
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const fs = require('fs');
            const path = require('path');
            const prUtils = require('./utils/scripts/pr-utils.js'); 
            let appendMsg = "\n - Submodules bumped \n\n";
            const mergeable = "${{ steps.pr-2.outputs.mergeable }}" === "true";
            if (mergeable) {
              appendMsg = appendMsg + "**_(Step 4/5)_** Skipping extra auto-resolve submodule conflicts with squash and rebase. (No conflicts detected)\n\n**_(Step 5/5)_** Starting to merge base."
            }
            else {
              appendMsg = appendMsg + "**_(Step 4/5)_** Starting extra auto-resolve submodule conflicts with squash and rebase."
            }
            await prUtils.appendComment(github, commentId, owner, repo, appendMsg);

      - name: Comment after Rebase
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const fs = require('fs');
            const path = require('path');
            const prUtils = require('./utils/scripts/pr-utils.js'); 
            const appendMsg = "\n - Rebase pushed successfully. \n\n**_(Step 5/5)_** Starting to merge base.";
            await prUtils.appendComment(github, commentId, owner, repo, appendMsg);

      - name: Comment on merge base success
        uses: actions/github-script@v7
        with:
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const fs = require('fs');
            const path = require('path');
            const prUtils = require('./utils/scripts/pr-utils.js'); 
            const appendMsg = "\n ### **üöÄ Base PR merged successfully.** ### \n";
            await prUtils.appendComment(github, commentId, owner, repo, appendMsg);

      - name: Comment on Failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        env:
          JOB_NAME: ${{ github.job }}
          FAIL_MSG_PERMISSIONS: ${{ steps.permissions.outputs.failMsg }}
          FAIL_MSG_PR: ${{ steps.pr.outputs.failMsg }}
          FAIL_MSG_DIFF_SUBMOD: ${{ steps.diff-submodules.outputs.failMsg }}
          FAIL_MSG_BASE_APPROVAL: ${{ steps.base-approvals.outputs.failMsg }}
          FAIL_MSG_SQUASH_REBASE: ${{ steps.squash-rebase.outputs.failMsg }}
          FAIL_MSG_PRE_CHECK_SUBMOD: ${{ steps.pre-check-submod.outputs.failMsg }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const job = process.env.JOB_NAME;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const fs = require('fs');
            const path = require('path');
            const prUtils = require('./utils/scripts/pr-utils.js'); 
            
            let failureMsg = "‚ùå **Job failed:** ";
            let appendMsg = "";
            let resolutionSteps = "";
              if ('${{ steps.permissions.conclusion }}' == 'failure'){
                appendMsg = process.env.FAIL_MSG_PERMISSIONS;
                resolutionSteps = "_Please check that you have permissions to perform this action and try again later._";
              } else if ('${{ steps.pr.conclusion }}' == 'failure'){
                appendMsg = "API failed to get information on base pr.";
                if (process.env.FAIL_MSG_PR)
                {
                  appendMsg = process.env.FAIL_MSG_PR 
                }
                resolutionSteps = "_Please try again later._";
              } else if ('${{ steps.read-modules-file.conclusion }}' == 'failure'){
                appendMsg = "Failed to read the .gitmodules file.";
                resolutionSteps = "_Please try again later._";
              } else if ('${{ steps.auth.conclusion }}' == 'failure'){
                appendMsg = "Failed to authenticate submodules with github. ";
                resolutionSteps = "_Please confirm you have pushed up your submodule branches._";
              } else if ('${{ steps.diff-submodules.conclusion }}' == 'failure'){
                appendMsg = "Submodule diff failed. "+ process.env.FAIL_MSG_DIFF_SUBMOD;
                resolutionSteps = "_Please try again later._";
              } else if ('${{ steps.base-approvals.conclusion }}' == 'failure'){
                appendMsg = "Base PR does not have enough approvals. "+ process.env.FAIL_MSG_BASE_APPROVAL;
                resolutionSteps = "_Please ensure your code is reviewed then try again._";
              } else if ('${{ steps.pre-check-submod.conclusion }}' == 'failure'){
                appendMsg = "Submodules failed pre-check. "+ process.env.FAIL_MSG_PRE_CHECK_SUBMOD;
                resolutionSteps = "_Please ensure there are no merge conflicts in your submodules and you have enough approvals._";
              } else if ('${{ steps.merge-submodules.conclusion }}' == 'failure'){
                appendMsg = "Submodule merge failed. ";
              } else if ('${{ steps.bump.conclusion }}' == 'failure') {
                failureMsg = "‚ùå **Job Submodule bump failed**";
                resolutionSteps = "_Please check the submodule configuration and try again. You can check the job logs on **Actions** tab for more information._";
              } else if ('${{ steps.squash-rebase.conclusion }}' == 'failure') {
                failureMsg = "‚ùå **Job Rebase failed**";
                resolutionSteps = process.env.FAIL_MSG_SQUASH_REBASE;
                resolutionSteps += "\n_Please locally resolve conflicts with a rebase or merge, push up your changes, and try again._";
              } else if ('${{ steps.merge-base.conclusion }}' == 'failure') {
                failureMsg = "‚ùå **Job Merge Base failed**\n The PR likely has merge conflicts. _Please manually resolve them and push the changes to this branch._";
              } else {
                appendMsg = "Unknown error. Please check the job logs on **Actions** tab for more information. ";
              };            
              
            const newBody = "\n\n" + failureMsg+appendMsg +"\n"+resolutionSteps;
            await prUtils.appendComment(github, commentId, owner, repo, newBody);
