name: Link/Investigate submodules

on:
  workflow_call:
    inputs:
      owner:
        description: 'Organization'
        required: true
        type: string
      repo:
        description: 'Repository'
        required: true
        type: string
      pr_number:
        description: 'Base PR Number'
        required: true
        type: number
      comment_id:
        description: 'Comment ID'
        required: true
        type: number
    secrets:
      token:
        description: 'Personal Access Token with RW access to repo contents, PRs'
        required: true

permissions:
  issues: write
  pull-requests: write
  contents: write

env:
  RW_PAT: ${{ secrets.token }}
  MIN_REVIEWERS: 2
  OWNER: ${{ inputs.owner }}
  REPO: ${{ inputs.repo }}
  BASE_PR_NUMBER: ${{ inputs.pr_number }}
  COMMENT_ID: ${{ inputs.comment_id }}

jobs:
  link-submods:
    runs-on: isg-ocp-x86-small
    timeout-minutes: 10
    steps:
      - name: Checkout utils repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          repository: MO-test-env/orgScripts
          ref: main
          path: utils
          sparse-checkout: scripts/pr-utils.js
          sparse-checkout-cone-mode: false
          token: ${{ env.RW_PAT }}

      - name: Comment start
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const runUrl = `https://github.com/${owner}/${repo}/actions/runs/${process.env.GITHUB_RUN_ID}`;
            let appendMsg = "\n# üîó Submodule Link Workflow\n";
            appendMsg += `[üñ•Ô∏è View workflow](${runUrl})\n`;
            appendMsg += "**_(Step 1/2)_** Fetching PR details and submodule info...";
            await github.rest.issues.updateComment({ owner, repo, comment_id: commentId,body: appendMsg, });

      - name: Get BasePR details
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = process.env.BASE_PR_NUMBER;
            const pr = await github.rest.pulls.get({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: prNumber,
            });
            core.setOutput("head_ref", pr.data.head.ref);
            core.setOutput("base_ref", pr.data.base.ref);
            
            // Get default branch of base repo 
            const { data: repo } = await github.rest.repos.get({
              owner: process.env.OWNER,
              repo: process.env.REPO,
            });
            core.setOutput("default_branch", repo.default_branch);
            core.setOutput("isMergeIntoDefaultBranch", pr.data.base.ref == repo.default_branch);
            
            // Get reviewers for the PR
            const { data: reviewData } = await github.rest.pulls.listRequestedReviewers({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: prNumber,
            });
            
            // Get all reviewers (both users and teams)
            const reviewers = reviewData.users ? reviewData.users.map(user => user.login) : [];
            const teamReviewers = reviewData.teams ? reviewData.teams.map(team => team.slug) : [];
            
            // Get assignees
            const assignees = pr.data.assignees ? pr.data.assignees.map(assignee => assignee.login) : [];
            
            core.setOutput("reviewers", JSON.stringify(reviewers));
            core.setOutput("team_reviewers", JSON.stringify(teamReviewers));
            core.setOutput("assignees", JSON.stringify(assignees));
            
            core.info(`Reviewers: ${JSON.stringify(reviewers)}`);
            core.info(`Team Reviewers: ${JSON.stringify(teamReviewers)}`);
            core.info(`Assignees: ${JSON.stringify(assignees)}`);

      - name: Determine changed submodules from PR diff
        id: diff-submodules
        uses: actions/github-script@v7
        env:
          BASE_REF: ${{ steps.pr.outputs.base_ref }}
          PR_REF: ${{ steps.pr.outputs.head_ref }}
          IS_MERGE_INTO_DEFAULT_BRANCH: ${{ steps.pr.outputs.isMergeIntoDefaultBranch }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = process.env.BASE_PR_NUMBER;
            const prUtils = require('./utils/scripts/pr-utils.js');
            let result = {};
            
            try {
              result = await prUtils.getChangedSubmodules(
                github, 
                core, 
                prNumber, 
                process.env.OWNER, 
                process.env.REPO
              );
            } catch (error) {
              core.setFailed(`Failed to determine changed submodules: ${error.message}`);
              core.setOutput("failMsg", `Workflow stopped because failed to determine changed submodules: ${error.message}`);
              return;
            }

            const isMergeIntoDefaultBranch = process.env.IS_MERGE_INTO_DEFAULT_BRANCH === 'true';
            
            try {
              result = await prUtils.submodDiff(
                github, 
                core, 
                prNumber, 
                process.env.OWNER, 
                process.env.REPO,
                isMergeIntoDefaultBranch
              );
            } catch (error) {
              core.warning(`Failed to get submodule diff: ${error.message}`);              
            }
            
            core.setOutput("changed_paths", JSON.stringify(result.changed_submodules));
            core.setOutput("conflicted_non_submodule_files", JSON.stringify(result.files_with_conflicts));
            core.setOutput("enriched_submodules", JSON.stringify(result.enriched_submodules));

      - name: Parse .gitmodules
        id: parse-gitmodules
        uses: actions/github-script@v7
        env:
          BASE_REF: ${{ steps.pr.outputs.base_ref }}
          CHANGED_PATHS: ${{ steps.diff-submodules.outputs.changed_paths }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const baseRef = process.env.BASE_REF;
            const changedPaths = JSON.parse(process.env.CHANGED_PATHS || "[]");
            const prUtils = require('./utils/scripts/pr-utils.js');
            
            let rawSubmodules = {};
            
            try {
              rawSubmodules = await prUtils.initSubmodsFromGitModules(
                github, 
                core, 
                0, // prNumber not used in this function
                owner, 
                repo, 
                baseRef, 
                changedPaths
              );
            } catch (error) {
              core.setFailed(`Failed to parse .gitmodules: ${error.message}`);
              core.setOutput("failMsg", `Workflow stopped because failed to parse .gitmodules: ${error.message}`);
              return;
            }
            
            core.setOutput("raw_submodules", JSON.stringify(rawSubmodules));

      - name: Pre-check all Submodules and add additional submodule fields 
        id: pre-check-submod
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.diff-submodules.outputs.enriched_submodules }}
          PR_BRANCH: ${{ steps.pr.outputs.head_ref }}
          BASE_BRANCH: ${{ steps.pr.outputs.base_ref }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const submods = JSON.parse(process.env.SUBMODULES_JSON);
            const submodulesAfterPrecheck = {};
            const prBranchName = process.env.PR_BRANCH;
            const baseBranchName = process.env.BASE_BRANCH;
            
            for (const [name, sub] of Object.entries(submods)) { 
              let prNumber = sub.prNumber;
              // If we already have a PR number from the previous step, use it
              if (prNumber !== null && prNumber !== undefined) {
                if (prNumber === 0) {
                  // Already merged (no pre-check needed)
                  submodulesAfterPrecheck[name] = {
                    ...sub,
                    prLink: null,
                    isPRCreated: false,
                    merged: true,
                    mergeableState: 'clean', 
                    approvals: null,
                  };
                } else if (prNumber === -1) {
                  // PR not created yet (no precheck needed)
                  submodulesAfterPrecheck[name] = {
                    ...sub,
                    prLink: null,
                    isPRCreated: false,
                    merged: false, 
                    approvals: null,
                  };
                } else {
                  // PR exists, need to pre-check/ fetch more info 
                    try {
                      // Check mergeability/ conflicts
                      // Retry logic for getting PR info when merged or mergeable_state is undefined
                      let prInfo = null;
                      let retryCount = 0;
                      const maxRetries = 3;
                      const retryDelay = 1000; // 1 second delay between retries
                      
                      while (retryCount <= maxRetries) {
                        try {
                          const response = await github.rest.pulls.get({
                            owner: process.env.OWNER,
                            repo: sub.repoName,
                            pull_number: prNumber
                          });
                          prInfo = response.data;
                          
                          // Check if we got the required information
                          if (prInfo.merged !== undefined && prInfo.mergeable_state !== undefined) {
                            break; // Success, exit retry loop
                          }
                          
                          // If we don't have the required info, retry if we haven't exceeded max retries
                          if (retryCount < maxRetries) {
                            retryCount++;
                            core.info(`PR info incomplete (merged: ${prInfo.merged}, mergeable_state: ${prInfo.mergeable_state}), retrying... (${retryCount}/${maxRetries})`);
                            await new Promise(resolve => setTimeout(resolve, retryDelay));
                          } else {
                            break; // Max retries reached
                          }
                        } catch (error) {
                          // If we get an error and haven't exceeded max retries, retry
                          if (retryCount < maxRetries) {
                            retryCount++;
                            core.info(`Error getting PR info: ${error.message}, retrying... (${retryCount}/${maxRetries})`);
                            await new Promise(resolve => setTimeout(resolve, retryDelay));
                          } else {
                            throw error; // Re-throw if max retries reached
                          }
                        }
                      }
                      
                      // If we still don't have the required info after retries, log a warning
                      if (prInfo.merged === undefined || prInfo.mergeable_state === undefined) {
                        core.warning(`PR info still incomplete after retries (merged: ${prInfo.merged}, mergeable_state: ${prInfo.mergeable_state})`);
                      }

                      // Check approvals 
                      const prUtils = require('./utils/scripts/pr-utils.js');
                      let approvalCount = 0;
                      let changeRequestCount = 0;
                      
                      try {
                        const result = await prUtils.checkPrApprovals(
                          github, 
                          core, 
                          prNumber, 
                          process.env.OWNER, 
                          sub.repoName
                        );
                        approvalCount = result.approvalCount;
                        changeRequestCount = result.changeRequestCount;
                      } catch (error) {
                        core.warning(`Error checking approvals for submodule ${name}: ${error.message}`);
                        // Continue with default values rather than failing the entire workflow
                      }
                      const prState = prInfo.number === 0 ? null : prInfo.merged_at ? 'merged' : prInfo.state === 'closed' ? 'closed' : 'open';
                      
                      // Push full object 
                      submodulesAfterPrecheck[name] = {
                        ...sub,
                        prLink: prInfo.html_url,
                        isPRCreated: true,
                        prState: prState,
                        merged: prInfo.merged,
                        mergeableState: prInfo.mergeable_state,
                        approvals: approvalCount,
                        changeRequests: changeRequestCount,
                      };
                    } catch (error) {
                      console.log(`Error getting additional PR info for submodule ${name}: ${error.message}`);
                    }
                }
                continue;
              }
            }
            
            // Convert object to array for output and later steps 
            const submodulesArray = Object.values(submodulesAfterPrecheck);
            const submodulesAfterPrecheckJson = JSON.stringify(submodulesArray, null, 2);
            core.info("Submodule JSON:");
            core.info(submodulesAfterPrecheckJson);
              core.setOutput('submod_after_precheck', submodulesAfterPrecheckJson);
            
            // Filter only unmerged submodules
            const unmerged = submodulesArray.filter(s => s.merged === false);
            const unmergedJson = JSON.stringify(unmerged, null, 2);
            core.info("Unmerged submodules:");
            core.info(unmergedJson);
            core.setOutput('unmerged', unmergedJson);
            

            // addl validation: ensure the number of submodules from the diff step matches the number in the pre-check step
            const submodulesFromDiff = JSON.parse(process.env.SUBMODULES_JSON);
            const diffSubmoduleCount = Object.keys(submodulesFromDiff).length;
            const precheckSubmoduleCount = submodulesArray.length;
            
            core.info(`Submodules from diff step: ${diffSubmoduleCount}, Submodules from pre-check step: ${precheckSubmoduleCount}`);
            
            // If the counts don't match, fail
            if (diffSubmoduleCount !== precheckSubmoduleCount) {
              const errorMsg = `Mismatch between submodules from diff step (${diffSubmoduleCount}) and pre-check step (${precheckSubmoduleCount}).`;
              core.setFailed(errorMsg);
              core.setOutput('failMsg', errorMsg);
            } else {
              core.info("Submodule counts match, validation passed.");
            }

      - name: Add reviewers and assignees to submodule PRs
        id: add-reviewers
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.pre-check-submod.outputs.submod_after_precheck }}
          REVIEWERS: ${{ steps.pr.outputs.reviewers }}
          TEAM_REVIEWERS: ${{ steps.pr.outputs.team_reviewers }}
          ASSIGNEES: ${{ steps.pr.outputs.assignees }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const submodules = JSON.parse(process.env.SUBMODULES_JSON);
            const reviewers = JSON.parse(process.env.REVIEWERS);
            const teamReviewers = JSON.parse(process.env.TEAM_REVIEWERS);
            const assignees = JSON.parse(process.env.ASSIGNEES);
            const owner = process.env.OWNER;
            
            core.info(`Adding reviewers ${JSON.stringify(reviewers)} and team reviewers ${JSON.stringify(teamReviewers)} to submodule PRs`);
            core.info(`Adding assignees ${JSON.stringify(assignees)} to submodule PRs`);
            
            // Process each submodule that has an open PR
            for (const submodule of submodules) {
              if (submodule.isPRCreated && submodule.prState === 'open' && submodule.prNumber) {

                try {
                  // Add reviewers if there are any and the submodule doesn't already have enough approvals
                  if ((reviewers.length > 0 || teamReviewers.length > 0) && 
                      (submodule.approvals < parseInt(process.env.MIN_REVIEWERS) || submodule.changeRequests > 0)) {
                    // Get current reviewers for the PR to avoid re-requesting from people already on the approvals list
                    const currentReviewers = await github.rest.pulls.listReviews({
                      owner: process.env.OWNER,
                      repo: submodule.repoName,
                      pull_number: submodule.prNumber,
                      per_page: 100
                    });
                    
                    // Extract usernames of reviewers who have already approved
                    const approvedReviewers = currentReviewers.data
                      .filter(review => review.state === 'APPROVED')
                      .map(review => review.user.login);
                    
                    // Filter out reviewers who have already approved
                    const newReviewers = reviewers.filter(reviewer => !approvedReviewers.includes(reviewer));
                    const newTeamReviewers = teamReviewers; // Teams are handled differently, keep as is
                    
                    // Only request reviews if there are new reviewers to add
                    if (newReviewers.length > 0 || newTeamReviewers.length > 0) {
                      await github.rest.pulls.requestReviewers({
                        owner: process.env.OWNER,
                        repo: submodule.repoName,
                        pull_number: submodule.prNumber,
                        reviewers: newReviewers,
                        team_reviewers: newTeamReviewers
                      });
                      core.info(`Added reviewers to PR #${submodule.pr_number} for ${submodule.repoName}`);
                    } else {
                      core.info(`All reviewers already approved PR #${submodule.pr_number} for ${submodule.repoName}, skipping review request`);
                    }
                  }
                  
                  // Add assignees if there are any
                  if (assignees.length > 0) {
                    await github.rest.issues.addAssignees({
                      owner: process.env.OWNER,
                      repo: submodule.repoName,
                      issue_number: submodule.prNumber,
                      assignees: assignees
                    });
                  }
                } catch (error) {
                  core.warning(`Error adding reviewers/assignees to PR #${submodule.prNumber} for ${submodule.repoName}: ${error.message}`);
                }
              }
            }
            
            // Store information about which PRs had reviewers added
            const prsWithReviewersAdded = submodules
              .filter(s => s.isPRCreated && s.prState === 'open' && s.prNumber)
              .map(s => ({ repo: s.repoName, pr: s.prNumber }));
            
            core.setOutput('prs_with_reviewers_added', JSON.stringify(prsWithReviewersAdded));

      - name: Add comment to submodule PRs linking back to base PR
        id: comment-submod-prs
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.pre-check-submod.outputs.submod_after_precheck }}
          BASE_PR_NUMBER: ${{ env.BASE_PR_NUMBER }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const submodulesAfterPrecheck = JSON.parse(process.env.SUBMODULES_JSON);
            const basePrNumber = process.env.BASE_PR_NUMBER;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            
            core.info(`Adding comments to submodule PRs linking back to base PR #${basePrNumber}`);
            
            // Construct the base PR URL
            const basePrUrl = `https://github.com/${owner}/${repo}/pull/${basePrNumber}`;
            
            // Process each submodule that has an open PR
            for (const submodule of submodulesAfterPrecheck) {
              if (submodule.isPRCreated && submodule.prState === 'open' && submodule.prNumber) {
                try {
                  // Check if there's already a comment linking back to the base PR
                  const existingComments = await github.rest.issues.listComments({
                    owner: process.env.OWNER,
                    repo: submodule.repoName,
                    issue_number: submodule.prNumber,
                    per_page: 100
                  });
                  
                  // Look for an existing comment that links back to the base PR
                  const existingComment = existingComments.data.find(comment => 
                    comment.body && 
                    comment.body.includes('This submodule PR is part of a larger change') 
                  );
                  
                  // Add a comment to the submodule PR linking back to the base PR
                  let commentBody = `## üîó This submodule PR is part of a larger change in the parent repository. \n`;
                  commentBody += `Please review the [base PR #${basePrNumber}](${basePrUrl}) for context on how this submodule change fits into the overall update.`;
                  commentBody += `\n_This comment was automatically added by the submodule linking workflow._`;
                  
                  if (existingComment) {
                    // Update the existing comment
                    await github.rest.issues.updateComment({
                      owner: process.env.OWNER,
                      repo: submodule.repoName,
                      comment_id: existingComment.id,
                      body: commentBody
                    });
                    core.info(`Updated existing comment #${existingComment.id} on PR #${submodule.prNumber} in ${submodule.repoName}`);
                  } else {
                    // Create a new comment
                    await github.rest.issues.createComment({
                      owner: process.env.OWNER,
                      repo: submodule.repoName,
                      issue_number: submodule.prNumber,
                      body: commentBody
                    });
                    core.info(`Added new comment to PR #${submodule.prNumber} in ${submodule.repoName} linking back to base PR #${basePrNumber}`);
                  }
                } catch (error) {
                  core.warning(`Error adding/updating comment to PR #${submodule.prNumber} for ${submodule.repoName}: ${error.message}`);
                }
              }
            }

      - name: Update comment with submodule PR links
        id: update-comment
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.pre-check-submod.outputs.submod_after_precheck }}
          PRS_WITH_REVIEWERS: ${{ steps.add-reviewers.outputs.prs_with_reviewers_added }}
          REVIEWERS: ${{ steps.pr.outputs.reviewers }}
          TEAM_REVIEWERS: ${{ steps.pr.outputs.team_reviewers }}
          ASSIGNEES: ${{ steps.pr.outputs.assignees }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const submodulesAfterPrecheck = JSON.parse(process.env.SUBMODULES_JSON);
            const prsWithReviewers = JSON.parse(process.env.PRS_WITH_REVIEWERS || '[]');
            
            function getStatusIcon(sub) {
              if (!sub.prBranch) return '‚ùå';
              if (!sub.isPRCreated && sub.prNumber === -1) return 'üîÑ';
              if (!sub.isPRCreated) return '‚òëÔ∏è';
              if (sub.approvals !== null && (sub.approvals < parseInt(process.env.MIN_REVIEWERS) || sub.changeRequests > 0)) return '‚è≥';
              if (sub.isPRCreated) return '‚úÖ';
              return '‚ùì';
            }
            
            function getStatusText(sub) {
              if (!sub.prBranch) return '**Branch missing**';
              if (!sub.isPRCreated && sub.prNumber === -1) return '**Create PR**';
              if (!sub.isPRCreated) return '**PR missing**';
              if (sub.approvals !== null) {
                if (sub.approvals < parseInt(process.env.MIN_REVIEWERS)) return '**Pending approval**';
                if (sub.changeRequests > 0) return '**Changes requested**';
                return '**Approved**';
              }
              return '**PR exists**';
            }
            
            let appendMsg = "\n**_(Step 2/2)_** Submodule Analysis:\n\n";
            appendMsg += "| Status | Submodule | Branch | PR | Approvals | State |\n";
            appendMsg += "|--------|-----------|--------|----|-----------|---------| \n";
            
            submodulesAfterPrecheck.forEach(sub => {
              const icon = getStatusIcon(sub);
              const prDisplay = sub.isPRCreated ? `[#${sub.prNumber}](${sub.prLink})` : (sub.prNumber === 0 ? 'On Delivery Branch' : (sub.prNumber === -1 ? '**Create PR**' : 'none'));
              const approvalsDisplay = sub.approvals !== null ? `${sub.approvals}` : '-';
              let stateDisplay = sub.merged || sub.prState || '-';
              if ( sub.prNumber === '0' ){
                stateDisplay = '-';
              }
              appendMsg += `| ${icon} | \`${sub.path}\` | \`${sub.prBranch}\` | ${prDisplay} | ${approvalsDisplay} | ${stateDisplay} |\n`;
            });
            
            appendMsg += "\n### üéØ Action Items\n\n";
            const missingBranches = submodulesAfterPrecheck.filter(s => !s.prBranch);
            const missingPRs = submodulesAfterPrecheck.filter(s => s.prBranch && !s.isPRCreated && s.prBranch !== s.baseBranch);
            const pendingApprovals = submodulesAfterPrecheck.filter(s => s.isPRCreated && (s.approvals < parseInt(process.env.MIN_REVIEWERS) || s.changeRequests > 0));
            
            // Check if reviewers were added to any PRs
            const reviewersAdded = prsWithReviewers.length > 0;
            
            if (missingBranches.length > 0) {
              appendMsg += `üåø **Create branches**: ${missingBranches.map(s => '`' + s.path + '`').join(', ')}\n`;
            }
            if (missingPRs.length > 0) {
              appendMsg += `üîÑ **Create PRs**:\n`;
              for (const sub of missingPRs) {
                // Skip if the branch is the default branch
                if (sub.prBranch === sub.baseBranch) {
                  continue;
                }
                
                // Extract the branch name from the prBranch property if available
                // Otherwise use the PR branch name from the base PR
                const prBranch = sub.prBranch ? sub.prBranch.replace(/^origin\//, '') : `${{ steps.pr.outputs.head_ref}}`;
                
                // Skip if the branch name is the same as the base branch
                if (prBranch === sub.baseBranch) {
                  continue;
                }
                
                const compareUrl = `https://github.com/${owner}/${sub.repoName}/compare/${sub.baseBranch}...${prBranch}?expand=1`;
                appendMsg += `- [Create PR for ${sub.repoName}](${compareUrl}) (${sub.baseBranch} ‚Üê ${prBranch})\n`;
              }
              appendMsg += '\n';
            }
            if (pendingApprovals.length > 0) {
              appendMsg += `üëÄ **Request reviews**: ${pendingApprovals.map(s => '[' + s.repoName + '#' + s.prNumber + '](' + s.prLink + ')').join(', ')}\n`;
            }
            if (reviewersAdded) {
              const reviewersList = JSON.parse(process.env.REVIEWERS || '[]');
              const teamReviewersList = JSON.parse(process.env.TEAM_REVIEWERS || '[]');
              const assigneesList = JSON.parse(process.env.ASSIGNEES || '[]');
              
              let reviewersInfo = '';
              if (reviewersList.length > 0 || teamReviewersList.length > 0) {
                reviewersInfo += `üë• **Reviewers In Sync** `;
              }
              appendMsg += reviewersInfo;
            }
            if (missingBranches.length === 0 && missingPRs.length === 0 && pendingApprovals.length === 0) {
              appendMsg += `‚úÖ All submodules are ready! Type /merge to merge everything.\n`;
            }
            
            appendMsg += "\n Workflow complete ";
            
            const prUtils = require('./utils/scripts/pr-utils.js');
            await prUtils.appendComment(github, commentId, owner, repo, appendMsg);

      - name: Comment on Failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        env:
          JOB_NAME: ${{ github.job }}
          FAIL_MSG_DIFF_SUBMODULES: ${{ steps.diff-submodules.outputs.failMsg }}
          FAIL_MSG_PRE_CHECK_SUBMOD: ${{ steps.pre-check-submod.outputs.failMsg }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const job = process.env.JOB_NAME;

            let failureMsg = "‚ùå **Job failed:** ";
            let appendMsg = "";
            let resolutionSteps = "";
            
            if ('${{ steps.diff-submodules.conclusion }}' == 'failure'){
              appendMsg = "Failed to parse submodule diff, get submodule PR branches, or submodule PR numbers." + (process.env.FAIL_MSG_DIFF_SUBMODULES || "");
              resolutionSteps = "_Please ensure you have pushed up your branches or ensure that the base sha is pointing to the right place._";
            } else if ('${{ steps.pre-check-submod.conclusion }}' == 'failure'){
              appendMsg = "Submodule pre-check failed. " + (process.env.FAIL_MSG_PRE_CHECK_SUBMOD || "");
              if (appendMsg.includes("Mismatch between submodules needing PRs")) {
                resolutionSteps = "_Please ensure all submodule changes have corresponding PRs. Each updated submodule must have exactly one PR, except for submodules already on their default branch._";
              } else {
                resolutionSteps = "_Please ensure all submodule PRs are created and properly linked._";
              }
            } else {
              appendMsg = "Unknown error. Please check the job logs on **Actions** tab for more information.";
              resolutionSteps = "_Please try again later._";
            }
            
            const newBody = "\n\n"+ failureMsg + appendMsg + "\n" + resolutionSteps;
            const prUtils = require('./utils/scripts/pr-utils.js');
            await prUtils.appendComment(github, commentId, process.env.OWNER, process.env.REPO, newBody);